class Node:
    def __init__(self, val, parents=(), tag=''):
        self.val = val
        self.d = 0.0
        self.parents = set(parents)
        self.tag = tag
        self.pull = lambda: None

    def __add__(self, x):
        x = x if isinstance(x, Node) else Node(x)
        y = Node(self.val + x.val, (self, x), 'add')

        def pull():
            self.d += y.d
            x.d += y.d
        y.pull = pull
        return y

    def __mul__(self, x):
        x = x if isinstance(x, Node) else Node(x)
        y = Node(self.val * x.val, (self, x), 'mul')

        def pull():
            self.d += x.val * y.d
            x.d += self.val * y.d
        y.pull = pull
        return y

    def __pow__(self, k):
        y = Node(self.val ** k, (self,), f'pow{k}')

        def pull():
            self.d += k * (self.val ** (k - 1)) * y.d
        y.pull = pull
        return y

    def relu(self):
        y = Node(self.val if self.val > 0 else 0, (self,), 'relu')

        def pull():
            self.d += (y.val > 0) * y.d
        y.pull = pull
        return y

    def backward(self):
        order = []
        seen = set()

        def visit(n):
            if n not in seen:
                seen.add(n)
                for p in n.parents:
                    visit(p)
                order.append(n)

        visit(self)
        self.d = 1.0
        for n in reversed(order):
            n.pull()

    def __neg__(self):
        return self * -1

    def __sub__(self, x):
        return self + (-x)

    def __rsub__(self, x):
        return Node(x) + (-self)

    def __radd__(self, x):
        return self + x

    def __rmul__(self, x):
        return self * x

    def __truediv__(self, x):
        return self * (x ** -1)

    def __rtruediv__(self, x):
        return Node(x) * (self ** -1)

    def __repr__(self):
        return f"Node(val={self.val}, grad={self.d})"
